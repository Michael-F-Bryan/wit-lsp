<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ARRAY_HEADER` constant in crate `tree_sitter`."><title>ARRAY_HEADER in tree_sitter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tree_sitter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.2 (25ef9e3d8 2024-04-09)" data-channel="1.77.2" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tree_sitter/index.html">tree_sitter</a><span class="version">0.22.5</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../tree_sitter/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="index.html">tree_sitter</a>::<wbr><a class="constant" href="#">ARRAY_HEADER</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/tree_sitter/lib.rs.html#46">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub const ARRAY_HEADER: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.77.2/std/primitive.str.html">str</a> = &quot;#ifndef TREE_SITTER_ARRAY_H_\n#define TREE_SITTER_ARRAY_H_\n\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n#include \&quot;./alloc.h\&quot;\n\n#include &lt;assert.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#ifdef _MSC_VER\n#pragma warning(disable : 4101)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \&quot;-Wunused-variable\&quot;\n#endif\n\n#define Array(T)       \\\n  struct {             \\\n    T *contents;       \\\n    uint32_t size;     \\\n    uint32_t capacity; \\\n  }\n\n/// Initialize an array.\n#define array_init(self) \\\n  ((self)-&gt;size = 0, (self)-&gt;capacity = 0, (self)-&gt;contents = NULL)\n\n/// Create an empty array.\n#define array_new() \\\n  { NULL, 0, 0 }\n\n/// Get a pointer to the element at a given `index` in the array.\n#define array_get(self, _index) \\\n  (assert((uint32_t)(_index) &lt; (self)-&gt;size), &amp;(self)-&gt;contents[_index])\n\n/// Get a pointer to the first element in the array.\n#define array_front(self) array_get(self, 0)\n\n/// Get a pointer to the last element in the array.\n#define array_back(self) array_get(self, (self)-&gt;size - 1)\n\n/// Clear the array, setting its size to zero. Note that this does not free any\n/// memory allocated for the array\&#39;s contents.\n#define array_clear(self) ((self)-&gt;size = 0)\n\n/// Reserve `new_capacity` elements of space in the array. If `new_capacity` is\n/// less than the array\&#39;s current capacity, this function has no effect.\n#define array_reserve(self, new_capacity) \\\n  _array__reserve((Array *)(self), array_elem_size(self), new_capacity)\n\n/// Free any memory allocated for this array. Note that this does not free any\n/// memory allocated for the array\&#39;s contents.\n#define array_delete(self) _array__delete((Array *)(self))\n\n/// Push a new `element` onto the end of the array.\n#define array_push(self, element)                            \\\n  (_array__grow((Array *)(self), 1, array_elem_size(self)), \\\n   (self)-&gt;contents[(self)-&gt;size++] = (element))\n\n/// Increase the array\&#39;s size by `count` elements.\n/// New elements are zero-initialized.\n#define array_grow_by(self, count) \\\n  do { \\\n    if ((count) == 0) break; \\\n    _array__grow((Array *)(self), count, array_elem_size(self)); \\\n    memset((self)-&gt;contents + (self)-&gt;size, 0, (count) * array_elem_size(self)); \\\n    (self)-&gt;size += (count); \\\n  } while (0)\n\n/// Append all elements from one array to the end of another.\n#define array_push_all(self, other)                                       \\\n  array_extend((self), (other)-&gt;size, (other)-&gt;contents)\n\n/// Append `count` elements to the end of the array, reading their values from the\n/// `contents` pointer.\n#define array_extend(self, count, contents)                    \\\n  _array__splice(                                               \\\n    (Array *)(self), array_elem_size(self), (self)-&gt;size, \\\n    0, count,  contents                                        \\\n  )\n\n/// Remove `old_count` elements from the array starting at the given `index`. At\n/// the same index, insert `new_count` new elements, reading their values from the\n/// `new_contents` pointer.\n#define array_splice(self, _index, old_count, new_count, new_contents)  \\\n  _array__splice(                                                       \\\n    (Array *)(self), array_elem_size(self), _index,                \\\n    old_count, new_count, new_contents                                 \\\n  )\n\n/// Insert one `element` into the array at the given `index`.\n#define array_insert(self, _index, element) \\\n  _array__splice((Array *)(self), array_elem_size(self), _index, 0, 1, &amp;(element))\n\n/// Remove one element from the array at the given `index`.\n#define array_erase(self, _index) \\\n  _array__erase((Array *)(self), array_elem_size(self), _index)\n\n/// Pop the last element off the array, returning the element by value.\n#define array_pop(self) ((self)-&gt;contents[--(self)-&gt;size])\n\n/// Assign the contents of one array to another, reallocating if necessary.\n#define array_assign(self, other) \\\n  _array__assign((Array *)(self), (const Array *)(other), array_elem_size(self))\n\n/// Swap one array with another\n#define array_swap(self, other) \\\n  _array__swap((Array *)(self), (Array *)(other))\n\n/// Get the size of the array contents\n#define array_elem_size(self) (sizeof *(self)-&gt;contents)\n\n/// Search a sorted array for a given `needle` value, using the given `compare`\n/// callback to determine the order.\n///\n/// If an existing element is found to be equal to `needle`, then the `index`\n/// out-parameter is set to the existing value\&#39;s index, and the `exists`\n/// out-parameter is set to true. Otherwise, `index` is set to an index where\n/// `needle` should be inserted in order to preserve the sorting, and `exists`\n/// is set to false.\n#define array_search_sorted_with(self, compare, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, compare, , needle, _index, _exists)\n\n/// Search a sorted array for a given `needle` value, using integer comparisons\n/// of a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_with`.\n#define array_search_sorted_by(self, field, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, _compare_int, field, needle, _index, _exists)\n\n/// Insert a given `value` into a sorted array, using the given `compare`\n/// callback to determine the order.\n#define array_insert_sorted_with(self, compare, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_with(self, compare, &amp;(value), &amp;_index, &amp;_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n/// Insert a given `value` into a sorted array, using integer comparisons of\n/// a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_by`.\n#define array_insert_sorted_by(self, field, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_by(self, field, (value) field, &amp;_index, &amp;_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n// Private\n\ntypedef Array(void) Array;\n\n/// This is not what you\&#39;re looking for, see `array_delete`.\nstatic inline void _array__delete(Array *self) {\n  if (self-&gt;contents) {\n    ts_free(self-&gt;contents);\n    self-&gt;contents = NULL;\n    self-&gt;size = 0;\n    self-&gt;capacity = 0;\n  }\n}\n\n/// This is not what you\&#39;re looking for, see `array_erase`.\nstatic inline void _array__erase(Array *self, size_t element_size,\n                                uint32_t index) {\n  assert(index &lt; self-&gt;size);\n  char *contents = (char *)self-&gt;contents;\n  memmove(contents + index * element_size, contents + (index + 1) * element_size,\n          (self-&gt;size - index - 1) * element_size);\n  self-&gt;size--;\n}\n\n/// This is not what you\&#39;re looking for, see `array_reserve`.\nstatic inline void _array__reserve(Array *self, size_t element_size, uint32_t new_capacity) {\n  if (new_capacity &gt; self-&gt;capacity) {\n    if (self-&gt;contents) {\n      self-&gt;contents = ts_realloc(self-&gt;contents, new_capacity * element_size);\n    } else {\n      self-&gt;contents = ts_malloc(new_capacity * element_size);\n    }\n    self-&gt;capacity = new_capacity;\n  }\n}\n\n/// This is not what you\&#39;re looking for, see `array_assign`.\nstatic inline void _array__assign(Array *self, const Array *other, size_t element_size) {\n  _array__reserve(self, element_size, other-&gt;size);\n  self-&gt;size = other-&gt;size;\n  memcpy(self-&gt;contents, other-&gt;contents, self-&gt;size * element_size);\n}\n\n/// This is not what you\&#39;re looking for, see `array_swap`.\nstatic inline void _array__swap(Array *self, Array *other) {\n  Array swap = *other;\n  *other = *self;\n  *self = swap;\n}\n\n/// This is not what you\&#39;re looking for, see `array_push` or `array_grow_by`.\nstatic inline void _array__grow(Array *self, uint32_t count, size_t element_size) {\n  uint32_t new_size = self-&gt;size + count;\n  if (new_size &gt; self-&gt;capacity) {\n    uint32_t new_capacity = self-&gt;capacity * 2;\n    if (new_capacity &lt; 8) new_capacity = 8;\n    if (new_capacity &lt; new_size) new_capacity = new_size;\n    _array__reserve(self, element_size, new_capacity);\n  }\n}\n\n/// This is not what you\&#39;re looking for, see `array_splice`.\nstatic inline void _array__splice(Array *self, size_t element_size,\n                                 uint32_t index, uint32_t old_count,\n                                 uint32_t new_count, const void *elements) {\n  uint32_t new_size = self-&gt;size + new_count - old_count;\n  uint32_t old_end = index + old_count;\n  uint32_t new_end = index + new_count;\n  assert(old_end &lt;= self-&gt;size);\n\n  _array__reserve(self, element_size, new_size);\n\n  char *contents = (char *)self-&gt;contents;\n  if (self-&gt;size &gt; old_end) {\n    memmove(\n      contents + new_end * element_size,\n      contents + old_end * element_size,\n      (self-&gt;size - old_end) * element_size\n    );\n  }\n  if (new_count &gt; 0) {\n    if (elements) {\n      memcpy(\n        (contents + index * element_size),\n        elements,\n        new_count * element_size\n      );\n    } else {\n      memset(\n        (contents + index * element_size),\n        0,\n        new_count * element_size\n      );\n    }\n  }\n  self-&gt;size += new_count - old_count;\n}\n\n/// A binary search routine, based on Rust\&#39;s `std::slice::binary_search_by`.\n/// This is not what you\&#39;re looking for, see `array_search_sorted_with` or `array_search_sorted_by`.\n#define _array__search_sorted(self, start, compare, suffix, needle, _index, _exists) \\\n  do { \\\n    *(_index) = start; \\\n    *(_exists) = false; \\\n    uint32_t size = (self)-&gt;size - *(_index); \\\n    if (size == 0) break; \\\n    int comparison; \\\n    while (size &gt; 1) { \\\n      uint32_t half_size = size / 2; \\\n      uint32_t mid_index = *(_index) + half_size; \\\n      comparison = compare(&amp;((self)-&gt;contents[mid_index] suffix), (needle)); \\\n      if (comparison &lt;= 0) *(_index) = mid_index; \\\n      size -= half_size; \\\n    } \\\n    comparison = compare(&amp;((self)-&gt;contents[*(_index)] suffix), (needle)); \\\n    if (comparison == 0) *(_exists) = true; \\\n    else if (comparison &lt; 0) *(_index) += 1; \\\n  } while (0)\n\n/// Helper macro for the `_sorted_by` routines below. This takes the left (existing)\n/// parameter by reference in order to work with the generic sorting function above.\n#define _compare_int(a, b) ((int)*(a) - (int)(b))\n\n#ifdef _MSC_VER\n#pragma warning(default : 4101)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_ARRAY_H_\n&quot;;</code></pre></section></div></main></body></html>